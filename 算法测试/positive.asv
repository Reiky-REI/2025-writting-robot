function compute_phi(xC,yC)
    % 已知参数
    l1 = 8.5; % 连杆AB
    l2 = 13; % 连杆BC
    l3 = 13; % 连杆CD
    l4 = 8.5; % 连杆DE
    l5 = 11.5; % 固定杆A
    % l6 = 3.5; % 杆FG
    % m = 2.5; % G距笔的距离
    % xC = 5.7500;
    % yC = 20.6965;
    % 计算方程 (5) 的系数
    d1 = -2 * l1 * yC;
    e1 = -2 * l1 * xC;
    f1 = xC^2 + yC^2 + l1^2 - l2^2;
    discriminant1 = d1^2 + e1^2 - f1^2;
    % 检查判别式是否为负，如果是则修正为一个小的正数避免复数
    if discriminant1 < 0
    discriminant1 = eps;
    end
    sqrt_discriminant1 = sqrt(discriminant1);
    denominator1 = e1 - f1;
    % 避免分母为零，如果分母接近零则修正为一个小的正数
    if abs(denominator1) < eps
    denominator1 = eps;
    end
    % 计算 phi1 的两个可能解
    phi1_1 = 2 * atan((d1 + sqrt_discriminant1) / denominator1);
    phi1_2 = 2 * atan((d1 - sqrt_discriminant1) / denominator1);
    % 将弧度转换为角度
    phi1_1_deg = rad2deg(phi1_1);
    phi1_2_deg = rad2deg(phi1_2);
    % 输出 phi1 的解（角度）
    fprintf('phi1 的第一个解: %.4f 度\n', phi1_1_deg);
    fprintf('phi1 的第二个解: %.4f 度\n', phi1_2_deg);
    % 计算方程 (6) 的系数
    d2 = -2 * l4 * yC;
    e2 = -2 * l4 * l5 - 2 * xC;
    f2 = xC^2 + yC^2 + l4^2 - l3^2 + l5^2 - 2 * xC * l5;
    discriminant2 = d2^2 + e2^2 - f2^2;
    % 检查判别式是否为负，如果是则修正为一个小的正数避免复数
    if discriminant2 < 0
    discriminant2 = eps;
    end
    sqrt_discriminant2 = sqrt(discriminant2);
    denominator2 = e2 - f2;
    % 避免分母为零，如果分母接近零则修正为一个小的正数
    if abs(denominator2) < eps
    denominator2 = eps;
    end
    % 计算 phi4 的两个可能解
    phi4_1 = 2 * atan((d2 + sqrt_discriminant2) / denominator2);
    phi4_2 = 2 * atan((d2 - sqrt_discriminant2) / denominator2);
    % 将弧度转换为角度
    phi4_1_deg = rad2deg(phi4_1);
    phi4_2_deg = rad2deg(phi4_2);
    A = [phi4_1_deg,phi4_2_deg];
    % % 输出 phi4 的解（角度）
    % fprintf('phi4 的第一个解: %.4f 度\n', phi4_1_deg);
    % fprintf('phi4 的第二个解: %.4f 度\n', phi4_2_deg);
    return A
end
